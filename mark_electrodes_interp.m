function h=mark_electrodes_interp(subject_name,dataroute,channel_list,channel_values,montage,varargin)
%h=mark_electrodes_interp(subject_name,dataroute,channel_list,channel_values,varargin)
%Mark the significant channels on a surface map(generated by freesurfer)
%Mark them with continuous color representating siginificance

%INPUT:
%subject_name: subject's name
%dataroute: this folder should contain 3 files:
%(1)locations of electrodes acquired by 'aquire_loc'
%(2)cortex picture generated by freesurfer or others
%(3)electrodes positions which is consistent with cortex picture, generated by freesurfer
%channel_list: the channels which are goint to be marked, exp.{'Amp1-1';'Amp1-2',...}
%channel_values: the weights of the channels
%varargin:
%C: the limit for normalizing channel weights

%OUTPUT
%h: produced figure's handle

%REQUIRE
%'*_loc.mat': locations of electrodes on the pic,  acquired by 'aquire_loc'
%'*_cortex.png' : pic of cortex
%'*_electrodes.png' : pic of electrodes
%'label_norm.mat' : channels' labels

% Version 5 , Chen Song, 2012-10-22
% Stable_version
% Revised from ZhengXiao's mapping_system by Chen Song
% Retry adding images
% Adding support for negative channel_values

locfile=[dataroute,subject_name,'_surface_loc_new01.mat'];
mapfile=[dataroute,subject_name,'_surface_new02.png'];  
electrodefile=[dataroute,subject_name,'_electrode_new02.png'];
load(locfile);   %name 'loc' and saved in acquire_loc.m
skull=imread(mapfile);
electrodes=imread(electrodefile);


switch montage
    case 1
        load('label_norm.mat');    %named label_norm, a constant list
        %usually locfile has the same order as 'label_norm' in sc_toolbox
        label_list=label_norm;
    case 2
        load('label_92.mat');  
        label_list=label_92;
    otherwise
        error('Montage not found!');
end

skull_flag=zeros(size(squeeze(skull(:,:,1))));  %denoting whether this point's color has been changed
skull_plus=zeros(size(skull_flag));     %The weights' layer

signif_chan=[];
for i=1:length(channel_list);
    indx=find(strcmp(channel_list{i},label_list));
    signif_chan=[signif_chan,indx];
end
% if max(signif_chan)~=length(loc)
%     error('Inconsistent number of electrodes between loc file and marking_channels');
% end


diameter=150;

%Set the plotting threshold (normalizing channel weights)
if nargin<6
   C=max(max(abs(channel_values)));  %normalize to [-1,1]
else
    if isnumeric(varargin{1})
        C=varargin{1};
    end
end

for ii=1:length(signif_chan)
    fff=signif_chan(ii);
    center_raw=[loc(fff,2),loc(fff,1)];
    [circle_model,rel_indx,true_indx] = circle_generate(center_raw,diameter);  
    for j=1:size(rel_indx,1)
        if true_indx(j,1)<=size(skull_flag,1)&&true_indx(j,2)<=size(skull_flag,2)&&...
                true_indx(j,1)>0&&true_indx(j,2)>0%may be out of range due to large diameter
            channel_value_norm=channel_values(ii)/C*circle_model(rel_indx(j,1),rel_indx(j,2));
            if skull_flag(true_indx(j,1),true_indx(j,2))==0
                skull_plus(true_indx(j,1),true_indx(j,2))=channel_value_norm;
                skull_flag(true_indx(j,1),true_indx(j,2))=1;    %The color of this point has already been changed               
            elseif skull_flag(true_indx(j,1),true_indx(j,2))==1
                skull_plus(true_indx(j,1),true_indx(j,2))=skull_plus(true_indx(j,1),true_indx(j,2))+channel_value_norm;
            end
        end
    end
end

%define transparency of skull_plus
trans_mat=abs(skull_plus);
trans_mat=trans_mat/max(max(trans_mat));

layer_filter=fspecial('gaussian',[40,40],80);
skull_plus_filtered=imfilter(skull_plus,layer_filter,'symmetric');
trans_mat=trans_mat.*skull_flag;   % 0 is transparent

trans_mat_electrodes=squeeze(electrodes(:,:,3));  %Using the Blue channel as transparency of electrodes

image_size=size(skull);image_size=fliplr(image_size(1:2));  %for adjustment of figure's gray outside edge
figure_size=image_size/10;
h=figure;
% set(h,'Position',[20,20,fliplr(size(skull_plus))]);
% set(h,'PaperUnits','inches','PaperPosition',[0 0 15.73 7.66]);
set(h,'PaperSize',figure_size);
set(h,'PaperPosition',[10,10,figure_size]);
set(h,'Position',[50,100,image_size]);

image_cortex=image(skull); hold on;
image_interp=imagesc(skull_plus_filtered,'AlphaData',trans_mat,'CDataMapping','scaled');  %Pseudocolor for 'skull_plus' layer
set(gca,'CLim',[-1,1],'CLimMode','manual');
% colorbar;
% colormap('Jet')
image_electrodes=image(electrodes,'AlphaData',trans_mat_electrodes);
hold off; 
set(gca,'Position',[0,0,1,1]); axis equal; axis off;